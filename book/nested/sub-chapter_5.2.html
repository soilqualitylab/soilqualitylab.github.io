<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Section 2: Hardware Optimization Strategies - Develop Your Life</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Develop Your Life</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="hardware-optimization-strategies"><a class="header" href="#hardware-optimization-strategies">Hardware Optimization Strategies</a></h2>
<p>You also may want to look at <em><strong>other</strong></em> Sections:</p>
<ul>
<li><a href="sub-chapter_5.1.html">Section 1: Foundations of Local Development for ML/AI</a></li>
<li><a href="sub-chapter_5.3.html">Section 3: Local Development Environment Setup</a></li>
<li><a href="sub-chapter_5.4.html">Section 4: Model Optimization Techniques</a></li>
<li><a href="sub-chapter_5.5.html">Section 5: MLOps Integration and Workflows</a></li>
<li><a href="sub-chapter_5.6.html">Section 6: Cloud Deployment Strategies</a></li>
<li><a href="sub-chapter_5.7.html">Section 7: Real-World Case Studies</a></li>
<li><a href="sub-chapter_5.8.html">Section 8: Future Trends and Advanced Topics</a></li>
</ul>
<h3 id="post-13-gpu-selection-strategy-for-local-mlai-development"><a class="header" href="#post-13-gpu-selection-strategy-for-local-mlai-development"><a href="#post-13">Post 13: GPU Selection Strategy for Local ML/AI Development</a></a></h3>
<p>This post provides comprehensive guidance on selecting the optimal GPU for local ML/AI development based on specific workloads and budgetary constraints. It examines the critical GPU specifications including VRAM capacity, memory bandwidth, tensor core performance, and power efficiency across NVIDIA's consumer (RTX) and professional (A-series) lineups. The post analyzes the performance-to-price ratio of different options, highlighting why used RTX 3090s (24GB) often represent exceptional value for ML/AI workloads compared to newer, more expensive alternatives. It includes detailed benchmarks showing the practical performance differences between GPU options when running common model architectures, helping developers make informed investment decisions based on their specific computational needs rather than marketing claims.</p>
<h3 id="post-14-understanding-the-vram-bottleneck-in-llm-development"><a class="header" href="#post-14-understanding-the-vram-bottleneck-in-llm-development"><a href="#post-14">Post 14: Understanding the VRAM Bottleneck in LLM Development</a></a></h3>
<p>This post explores why VRAM capacity represents the primary bottleneck for local LLM development and how to calculate your specific VRAM requirements based on model size and architecture. It examines how transformer-based models allocate VRAM across parameters, KV cache, gradients, and optimizer states during both inference and training phases. The post details the specific VRAM requirements for popular model sizes (7B, 13B, 70B) under different precision formats (FP32, FP16, INT8, INT4). It provides a formula for predicting VRAM requirements based on parameter count and precision, allowing developers to assess whether specific models will fit within their hardware constraints. This understanding helps teams make informed decisions about hardware investments and model optimization strategies to maximize local development capabilities.</p>
<h3 id="post-15-system-ram-optimization-for-mlai-workloads"><a class="header" href="#post-15-system-ram-optimization-for-mlai-workloads"><a href="#post-15">Post 15: System RAM Optimization for ML/AI Workloads</a></a></h3>
<p>This post examines the critical role of system RAM in ML/AI development, especially when implementing CPU offloading strategies to compensate for limited GPU VRAM. It explores how increasing system RAM (64GB to 128GB+) dramatically expands the size and complexity of models that can be run locally through offloading techniques. The post details the technical relationship between system RAM and GPU VRAM when using libraries like Hugging Face Accelerate for efficient memory management. It provides benchmarks showing the performance implications of different RAM configurations when running various model sizes with offloading enabled. These insights help developers understand how strategic RAM upgrades can significantly extend their local development capabilities at relatively low cost compared to GPU upgrades.</p>
<h3 id="post-16-cpu-considerations-for-mlai-development"><a class="header" href="#post-16-cpu-considerations-for-mlai-development"><a href="#post-16">Post 16: CPU Considerations for ML/AI Development</a></a></h3>
<p>This post explores the often-underestimated role of CPU capabilities in ML/AI development workflows and how to optimize CPU selection for specific AI tasks. It examines how CPU performance directly impacts data preprocessing, model loading times, and inference speed when using CPU offloading techniques. The post details the specific CPU features that matter most for ML workflows, including core count, single-thread performance, cache size, and memory bandwidth. It provides benchmarks comparing AMD and Intel processor options across different ML workloads, highlighting scenarios where high core count matters versus those where single-thread performance is more crucial. These insights help teams make informed CPU selection decisions that complement their GPU investments, especially for workflows that involve substantial CPU-bound preprocessing or offloading components.</p>
<h3 id="post-17-storage-architecture-for-mlai-development"><a class="header" href="#post-17-storage-architecture-for-mlai-development"><a href="#post-17">Post 17: Storage Architecture for ML/AI Development</a></a></h3>
<p>This post examines optimal storage configurations for ML/AI development, where dataset size and model checkpoint management create unique requirements beyond typical computing workloads. It explores the impact of storage performance on training throughput, particularly for data-intensive workloads with large datasets that cannot fit entirely in RAM. The post details tiered storage strategies that balance performance and capacity using combinations of NVMe, SATA SSD, and HDD technologies for different components of the ML workflow. It provides benchmark data showing how storage bottlenecks can limit GPU utilization in data-intensive applications and how strategic storage optimization can unlock full hardware potential. These considerations are particularly important as dataset sizes continue to grow exponentially, often outpacing increases in available RAM and necessitating efficient storage access patterns.</p>
<h3 id="post-18-cooling-and-power-considerations-for-ai-workstations"><a class="header" href="#post-18-cooling-and-power-considerations-for-ai-workstations"><a href="#post-18">Post 18: Cooling and Power Considerations for AI Workstations</a></a></h3>
<p>This post addresses the often-overlooked thermal and power management challenges of high-performance AI workstations, which can significantly impact sustained performance and hardware longevity. It examines how intensive GPU computation generates substantial heat that requires thoughtful cooling solutions beyond standard configurations. The post details power supply requirements for systems with high-end GPUs (350-450W each), recommending appropriate PSU capacity calculations that include adequate headroom for power spikes. It provides practical cooling solutions ranging from optimized airflow configurations to liquid cooling options, with specific recommendations based on different chassis types and GPU configurations. These considerations are crucial for maintaining stable performance during extended training sessions and avoiding thermal throttling that can silently degrade computational efficiency.</p>
<h3 id="post-19-multi-gpu-configurations-planning-and-implementation"><a class="header" href="#post-19-multi-gpu-configurations-planning-and-implementation"><a href="#post-19">Post 19: Multi-GPU Configurations: Planning and Implementation</a></a></h3>
<p>This post explores the technical considerations and practical benefits of implementing multi-GPU configurations for local ML/AI development. It examines the hardware requirements for stable multi-GPU setups, including motherboard selection, PCIe lane allocation, power delivery, and thermal management challenges. The post details software compatibility considerations for effectively leveraging multiple GPUs across different frameworks (PyTorch, TensorFlow) and parallelization strategies (data parallel, model parallel, pipeline parallel). It provides benchmarks showing scaling efficiency across different workloads, highlighting when multi-GPU setups provide linear performance improvements versus diminishing returns. These insights help organizations decide whether investing in multiple medium-tier GPUs might provide better price/performance than a single high-end GPU for their specific workloads.</p>
<h3 id="post-20-networking-infrastructure-for-hybrid-development"><a class="header" href="#post-20-networking-infrastructure-for-hybrid-development"><a href="#post-20">Post 20: Networking Infrastructure for Hybrid Development</a></a></h3>
<p>This post examines the networking requirements for efficiently bridging local development environments with cloud resources in hybrid ML/AI workflows. It explores how network performance impacts data transfer speeds, remote collaboration capabilities, and model synchronization between local and cloud environments. The post details recommended network configurations for different scenarios, from high-speed local networks for multi-machine setups to optimized VPN configurations for secure cloud connectivity. It provides benchmarks showing how networking bottlenecks can impact development-to-deployment workflows and strategies for optimizing data transfer patterns to minimize these impacts. These considerations are particularly important for organizations implementing GitOps and MLOps practices that require frequent synchronization between local development environments and cloud deployment targets.</p>
<h3 id="post-21-workstation-form-factors-and-expandability"><a class="header" href="#post-21-workstation-form-factors-and-expandability"><a href="#post-21">Post 21: Workstation Form Factors and Expandability</a></a></h3>
<p>This post explores the practical considerations around physical form factors, expandability, and noise levels when designing ML/AI workstations for different environments. It examines the tradeoffs between tower, rack-mount, and specialized AI workstation chassis designs, with detailed analysis of cooling efficiency, expansion capacity, and desk footprint. The post details expansion planning strategies that accommodate future GPU, storage, and memory upgrades without requiring complete system rebuilds. It provides noise mitigation approaches for creating productive work environments even with high-performance hardware, including component selection, acoustic dampening, and fan curve optimization. These considerations are particularly relevant for academic and corporate environments where workstations must coexist with other activities, unlike dedicated server rooms where noise and space constraints are less restrictive.</p>
<h3 id="post-22-path-1-high-vram-pc-workstation-nvidia-cuda-focus"><a class="header" href="#post-22-path-1-high-vram-pc-workstation-nvidia-cuda-focus"><a href="#post-22">Post 22: Path 1: High-VRAM PC Workstation (NVIDIA CUDA Focus)</a></a></h3>
<p>This post provides a comprehensive blueprint for building or upgrading a PC workstation optimized for ML/AI development with NVIDIA GPUs and the CUDA ecosystem. It examines specific component selection criteria including motherboards with adequate PCIe lanes, CPUs with optimal core counts and memory bandwidth, and power supplies with sufficient capacity for high-end GPUs. The post details exact recommended configurations at different price points, from entry-level development setups to high-end workstations capable of training medium-sized models. It provides a component-by-component analysis of performance impact on ML workloads, helping developers prioritize their component selection and upgrade path based on budget constraints. This focused guidance helps organizations implement the most cost-effective hardware configurations specifically optimized for CUDA-accelerated ML development rather than general-purpose workstations.</p>
<h3 id="post-23-path-2-apple-silicon-workstation-unified-memory-focus"><a class="header" href="#post-23-path-2-apple-silicon-workstation-unified-memory-focus"><a href="#post-23">Post 23: Path 2: Apple Silicon Workstation (Unified Memory Focus)</a></a></h3>
<p>This post explores the unique advantages and limitations of Apple Silicon-based workstations for ML/AI development, focusing on the transformative impact of the unified memory architecture. It examines how Apple's M-series chips (particularly M3 Ultra configurations) allow models to access large memory pools (up to 192GB) without the traditional VRAM bottleneck of discrete GPU systems. The post details the specific performance characteristics of Metal Performance Shaders (MPS) compared to CUDA, including framework compatibility, optimization techniques, and performance benchmarks across different model architectures. It provides guidance on selecting optimal Mac configurations based on specific ML workloads, highlighting scenarios where Apple Silicon excels (memory-bound tasks) versus areas where traditional NVIDIA setups maintain advantages (raw computational throughput, framework compatibility). This information helps organizations evaluate whether the Apple Silicon path aligns with their specific ML development requirements and existing technology investments.</p>
<h3 id="post-24-path-3-nvidia-dgx-sparkstation-high-end-local-ai"><a class="header" href="#post-24-path-3-nvidia-dgx-sparkstation-high-end-local-ai"><a href="#post-24">Post 24: Path 3: NVIDIA DGX Spark/Station (High-End Local AI)</a></a></h3>
<p>This post provides an in-depth analysis of NVIDIA's DGX Spark and DGX Station platforms as dedicated local AI development solutions bridging the gap between consumer hardware and enterprise systems. It examines the specialized architecture of these systems, including their Grace Blackwell platforms, large coherent memory pools, and optimized interconnects designed specifically for AI workloads. The post details benchmark performance across various ML tasks compared to custom-built alternatives, analyzing price-to-performance ratios and total cost of ownership. It provides implementation guidance for organizations considering these platforms, including integration with existing infrastructure, software compatibility, and scaling approaches. These insights help organizations evaluate whether these purpose-built AI development platforms justify their premium pricing compared to custom-built alternatives for their specific computational needs and organizational constraints.</p>
<h3 id="post-25-future-proofing-hardware-investments"><a class="header" href="#post-25-future-proofing-hardware-investments"><a href="#post-25">Post 25: Future-Proofing Hardware Investments</a></a></h3>
<p>This post explores strategies for making hardware investments that retain value and performance relevance over multiple years despite the rapidly evolving ML/AI landscape. It examines the historical depreciation and performance evolution patterns of different hardware components to identify which investments typically provide the longest useful lifespan. The post details modular upgrade approaches that allow incremental improvements without complete system replacements, focusing on expandable platforms with upgrade headroom. It provides guidance on timing purchases around product cycles, evaluating used enterprise hardware opportunities, and assessing when to wait for upcoming technologies versus investing immediately. These strategies help organizations maximize the return on their hardware investments by ensuring systems remain capable of handling evolving computational requirements without premature obsolescence.</p>
<h3 id="post-26-opportunistic-hardware-acquisition-strategies"><a class="header" href="#post-26-opportunistic-hardware-acquisition-strategies"><a href="#post-26">Post 26: Opportunistic Hardware Acquisition Strategies</a></a></h3>
<p>This post presents creative approaches for acquiring high-performance ML/AI hardware at significantly reduced costs through strategic timing and market knowledge. It examines the opportunities presented by corporate refresh cycles, data center decommissioning, mining hardware sell-offs, and bankruptcy liquidations for accessing enterprise-grade hardware at fraction of retail prices. The post details how to evaluate used enterprise hardware, including inspection criteria, testing procedures, and warranty considerations when purchasing from secondary markets. It provides examples of organizations that built powerful ML infrastructure through opportunistic acquisition, achieving computational capabilities that would have been financially unfeasible at retail pricing. These approaches can be particularly valuable for academic institutions, startups, and research teams operating under tight budget constraints while needing substantial computational resources.</p>
<h3 id="post-27-virtualization-and-resource-sharing-for-team-environments"><a class="header" href="#post-27-virtualization-and-resource-sharing-for-team-environments"><a href="#post-27">Post 27: Virtualization and Resource Sharing for Team Environments</a></a></h3>
<p>This post explores how virtualization and resource sharing technologies can maximize the utility of local ML/AI hardware across teams with diverse and fluctuating computational needs. It examines container-based virtualization, GPU passthrough techniques, and resource scheduling platforms that enable efficient hardware sharing without performance degradation. The post details implementation approaches for different team sizes and usage patterns, from simple time-sharing schedules to sophisticated orchestration platforms like Slurm and Kubernetes. It provides guidance on monitoring resource utilization, implementing fair allocation policies, and resolving resource contention in shared environments. These approaches help organizations maximize the return on hardware investments by ensuring high utilization across multiple users and projects rather than allowing powerful resources to sit idle when specific team members are not actively using them.</p>
<h3 id="post-28-making-the-business-case-for-local-hardware-investments"><a class="header" href="#post-28-making-the-business-case-for-local-hardware-investments"><a href="#post-28">Post 28: Making the Business Case for Local Hardware Investments</a></a></h3>
<p>This post provides a comprehensive framework for ML/AI teams to effectively communicate the business value of local hardware investments to financial decision-makers within their organizations. It examines how to translate technical requirements into business language, focusing on ROI calculations, productivity impacts, and risk mitigation rather than technical specifications. The post details how to document current cloud spending patterns, demonstrate breakeven timelines for hardware investments, and quantify the productivity benefits of reduced iteration time for development teams. It provides templates for creating compelling business cases with sensitivity analysis, competitive benchmarking, and clear success metrics that resonate with financial stakeholders. These approaches help technical teams overcome budget objections by framing hardware investments as strategic business decisions rather than technical preferences.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../nested/sub-chapter_5.1.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../nested/sub-chapter_5.3.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../nested/sub-chapter_5.1.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../nested/sub-chapter_5.3.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
